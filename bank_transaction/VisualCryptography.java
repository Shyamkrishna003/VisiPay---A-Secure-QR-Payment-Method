package com.example.bank_transaction;

import android.graphics.Bitmap;
import android.graphics.Color;
import android.util.Log;

/**
 * Class implementing visual cryptography for secure image sharing
 */
public class VisualCryptography {
    // Tag for logging purposes
    private static final String TAG = "VisualCryptography";
    
    // Each pixel is expanded into a 2x2 pattern
    private static final int PATTERN_SIZE = 2;
    
    // Used to determine if pixel should be black or white
    private static final double THRESHOLD = 0.5;
    
    // Window size for post-processing enhancement
    private static final int ENHANCEMENT_WINDOW_SIZE = 5;

    /**
     * Creates two shares from original image
     * @param originalBitmap Source image to encrypt
     * @return Array containing two share bitmaps
     */
    public static Bitmap[] generateShares(Bitmap originalBitmap) {
        // Validate input
        if (originalBitmap == null) {
            Log.e(TAG, "Original bitmap is null");
            return null;
        }

        try {
            // Calculate dimensions for shares (2x original size)
            int width = originalBitmap.getWidth() * PATTERN_SIZE;
            int height = originalBitmap.getHeight() * PATTERN_SIZE;

            // Create empty bitmaps for shares
            Bitmap share1 = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
            Bitmap share2 = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);

            // Process each pixel of original image
            for (int x = 0; x < originalBitmap.getWidth(); x++) {
                for (int y = 0; y < originalBitmap.getHeight(); y++) {
                    // Get pixel color and determine if it's black
                    int pixel = originalBitmap.getPixel(x, y);
                    boolean isBlack = isPixelBlack(pixel);

                    // Generate patterns for visual cryptography
                    boolean[][] pattern1 = generatePattern(isBlack);
                    boolean[][] pattern2 = generateComplementaryPattern(pattern1, isBlack);

                    // Apply patterns to shares
                    applyPattern(share1, x * PATTERN_SIZE, y * PATTERN_SIZE, pattern1);// Apply pattern1 to share1
                    applyPattern(share2, x * PATTERN_SIZE, y * PATTERN_SIZE, pattern2);// Apply pattern2 to share2
                }
            }

            return new Bitmap[]{share1, share2};// Return the generated shares
        } catch (Exception e) {// Handle any exceptions that occur during share generation
            // Log the error message
            Log.e(TAG, "Error generating shares: " + e.getMessage());
            return null;
        }
    }

    /**
     * Combines two shares to reconstruct original image
     */

    // This method decrypts the shares generated by the visual cryptography algorithm.
    // It takes two bitmap shares as input and reconstructs the original image by processing each block of pixels.
    public static Bitmap decryptShares(Bitmap share1, Bitmap share2) {
        if (!validateShares(share1, share2)) {
            Log.e(TAG, "Invalid shares provided for decryption");
            return null;
        }

        try {
            int originalWidth = share1.getWidth() / PATTERN_SIZE;// Calculate original width
            int originalHeight = share1.getHeight() / PATTERN_SIZE;// Calculate original height

            Bitmap decryptedBitmap = Bitmap.createBitmap(originalWidth, originalHeight,
                    Bitmap.Config.ARGB_8888);// Create empty bitmap for decrypted image

            for (int x = 0; x < originalWidth; x++) {
                for (int y = 0; y < originalHeight; y++) {
                    processBlock(share1, share2, decryptedBitmap, x, y);
                }
            }

            return applyPostProcessing(decryptedBitmap);// Apply post-processing to enhance the decrypted image
        } catch (Exception e) {
            Log.e(TAG, "Error during decryption: " + e.getMessage());
            return null;
        }
    }

    /**
     * Generates basic pattern for a pixel
     */
    private static boolean[][] generatePattern(boolean isBlack) {
        boolean[][] pattern = new boolean[PATTERN_SIZE][PATTERN_SIZE];
        if (isBlack) {
            // Pattern for black pixel: diagonal black pixels
            pattern[0][0] = true;   // Top-left: black
            pattern[1][1] = true;   // Bottom-right: black
            pattern[0][1] = false;  // Top-right: white
            pattern[1][0] = false;  // Bottom-left: white
        } else {
            // Pattern for white pixel: alternative pattern
            pattern[0][0] = true;   // Top-left: black
            pattern[1][1] = false;  // Bottom-right: white
            pattern[0][1] = true;   // Top-right: black
            pattern[1][0] = false;  // Bottom-left: white
        }
        return pattern;
    }






//This Java method generates a complementary pattern to the input pattern1. 
// If the input pixel is black (isBlack is true), it inverts the corresponding pixels in pattern1 to create pattern2.
//  If the input pixel is white (isBlack is false), it copies pattern1 to pattern2.



    private static boolean[][] generateComplementaryPattern(boolean[][] pattern1, boolean isBlack) {
        boolean[][] pattern2 = new boolean[PATTERN_SIZE][PATTERN_SIZE];

        for (int i = 0; i < PATTERN_SIZE; i++) {
            for (int j = 0; j < PATTERN_SIZE; j++) {
                pattern2[i][j] = isBlack ? !pattern1[i][j] : pattern1[i][j];
            }
        }
        return pattern2;
    }



//This Java method applies a given 2D pattern to a specific region of a bitmap image.
//  It sets pixels in the bitmap to either black or white based on the corresponding values in the pattern,
//  starting from the specified coordinates (startX, startY). The pattern is repeated for a size of PATTERN_SIZE x PATTERN_SIZE pixels.

    private static void applyPattern(Bitmap share, int startX, int startY, boolean[][] pattern) {
        for (int i = 0; i < PATTERN_SIZE; i++) {
            for (int j = 0; j < PATTERN_SIZE; j++) {
                share.setPixel(startX + i, startY + j, pattern[i][j] ? Color.BLACK : Color.WHITE);
            }
        }
    }


//This Java method validates two bitmap images (share1 and share2) to ensure they are compatible for decryption.
// It checks if both images are not null, have the same dimensions, and their dimensions are multiples of PATTERN_SIZE.
// If all conditions are met, it returns true; otherwise, it returns false.
    private static boolean validateShares(Bitmap share1, Bitmap share2) {
        if (share1 == null || share2 == null) {// Check if either share is null
            return false;// Return false if any share is null
        }// Check if both shares have the same dimensions

        return share1.getWidth() == share2.getWidth() && // Check if both shares have the same width
                share1.getHeight() == share2.getHeight() && // Check if both shares have the same height
                share1.getWidth() % PATTERN_SIZE == 0 && // Check if width is a multiple of PATTERN_SIZE
                share1.getHeight() % PATTERN_SIZE == 0; // Check if height is a multiple of PATTERN_SIZE
    }


//This Java method processes a block of pixels from two share images (share1 and share2) to determine the color of the corresponding pixel in the output image.
// It calculates the number of matching pixels in a PATTERN_SIZE x PATTERN_SIZE block and determines if the original pixel should be black or white based on a threshold ratio.
    private static void processBlock(Bitmap share1, Bitmap share2, Bitmap output,
                                     int blockX, int blockY) {
        int matchingPixels = 0;// Count of matching pixels in the block
        // Calculate the total number of pixels in the block
        int totalPixels = PATTERN_SIZE * PATTERN_SIZE;// Total pixels in the block
        // Iterate through each pixel in the block

        for (int i = 0; i < PATTERN_SIZE; i++) {
            for (int j = 0; j < PATTERN_SIZE; j++) {
                int x = blockX * PATTERN_SIZE + i;// Get the coordinates of the current pixel
                int y = blockY * PATTERN_SIZE + j;// Get the coordinates of the current pixel

                boolean pixel1Black = isPixelBlack(share1.getPixel(x, y));// Get pixel color from share1
                boolean pixel2Black = isPixelBlack(share2.getPixel(x, y));// Get pixel color from share2

                if (pixel1Black == pixel2Black) {
                    matchingPixels++;// Increment matching pixel count
                }
            }
        }// Calculate the ratio of matching pixels

        double matchRatio = (double) matchingPixels / totalPixels;
        boolean isOriginalPixelBlack = matchRatio > THRESHOLD;
        output.setPixel(blockX, blockY, isOriginalPixelBlack ? Color.BLACK : Color.WHITE);
    }


//This Java method applies post-processing to enhance the decrypted image by using a median filter with an adaptive threshold.
// It iterates through each pixel in the input bitmap, counts the number of black pixels in a surrounding window, and sets the output pixel to black or white based on the ratio of black pixels.
// The size of the window is defined by ENHANCEMENT_WINDOW_SIZE.

    private static Bitmap applyPostProcessing(Bitmap input) {
        int width = input.getWidth();// Get the width and height of the input bitmap
        int height = input.getHeight();// Get the height of the input bitmap
        // Create an output bitmap with the same dimensions as the input
        Bitmap output = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
        int halfWindow = ENHANCEMENT_WINDOW_SIZE / 2;// Calculate half the window size for the median filter
        // Iterate through each pixel in the input bitmap

        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                int blackCount = 0;// Count of black pixels in the surrounding window
                int totalPixels = 0;// Total number of pixels in the surrounding window
                // Iterate through the surrounding window

                // Apply median filter with adaptive threshold
                for (int wx = -halfWindow; wx <= halfWindow; wx++) {
                    for (int wy = -halfWindow; wy <= halfWindow; wy++) {
                        int newX = x + wx;// Calculate the new x-coordinate
                        int newY = y + wy;// Calculate the new y-coordinate

                        if (isValidCoordinate(newX, newY, width, height)) {
                            if (isPixelBlack(input.getPixel(newX, newY))) {
                                blackCount++;// Increment black pixel count
                            }
                            totalPixels++;// Increment total pixel count
                        }// Check if the new coordinates are valid
                    }
                }

                double blackRatio = (double) blackCount / totalPixels;// Calculate the ratio of black pixels
                output.setPixel(x, y, blackRatio > THRESHOLD ? Color.BLACK : Color.WHITE);// Set the output pixel color based on the ratio
                // Set the output pixel color based on the ratio of black pixels
            }
        }

        return output;
    }


//This Java method checks if the given coordinates (x, y) are within the bounds of the bitmap dimensions (width, height).
// It returns true if the coordinates are valid (within bounds), otherwise false.
// This is useful for ensuring that pixel access does not go out of bounds during processing.

    private static boolean isValidCoordinate(int x, int y, int width, int height) {
        return x >= 0 && x < width && y >= 0 && y < height;
    }

    private static boolean isPixelBlack(int pixel) {
        // Use ITU-R BT.709 coefficients for grayscale conversion
        double grayscale = (0.2126 * Color.red(pixel) +
                0.7152 * Color.green(pixel) +
                0.0722 * Color.blue(pixel));
        return grayscale < 128;
    }

//This Java method logs information about the shares generated from the original image.
// It checks if the shares are not null, logs their dimensions, and samples a few pixels to verify the pattern structure.
// The method uses the log tag "VisualCryptography" for logging and provides details about the share dimensions and pixel values at a specific location.
// The pixel values are checked to determine if they are black or white, which helps in debugging and verifying the visual cryptography process.

    /**
     * Logs information about two bitmap shares used in visual cryptography.
     *
     * <p>This method checks if the provided bitmap shares are null, logs their dimensions,
     * and samples a pixel from the center of the shares to verify the pattern structure.
     *
     * @param share1 The first bitmap share to analyze.
     * @param share2 The second bitmap share to analyze.
     */
    public static void logSharesInfo(Bitmap share1, Bitmap share2) {
        // Check if either of the shares is null and log a message if so.
        if (share1 == null || share2 == null) {
            Log.d(TAG, "One or both shares are null");
            return;
        }

        // Log the dimensions of the first share.
        Log.d(TAG, String.format("Share 1 dimensions: %dx%d", share1.getWidth(), share1.getHeight()));

        // Log the dimensions of the second share.
        Log.d(TAG, String.format("Share 2 dimensions: %dx%d", share2.getWidth(), share2.getHeight()));

        // Log the size of the pattern used in the visual cryptography.
        Log.d(TAG, String.format("Pattern size: %d", PATTERN_SIZE));

        // Calculate the coordinates of the center pixel in the first share.
        int testX = share1.getWidth() / 2;
        int testY = share1.getHeight() / 2;

        // Log the color information of the center pixel in both shares.
        Log.d(TAG, String.format("Sample pixel at (%d,%d): Share1=%b, Share2=%b",
                testX, testY,
                isPixelBlack(share1.getPixel(testX, testY)), // Check if the pixel in share1 is black.
                isPixelBlack(share2.getPixel(testX, testY))  // Check if the pixel in share2 is black.
        ));
    }
}